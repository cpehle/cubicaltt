module hopftotal2 where

import prelude
import equiv

NONABSTRACT : Unit = tt
ABSTRACT : Unit = ?

-- ----------------------------------------------------------------------
-- library

ap (A : U) (B : A -> U) 
   (f : (x : A) -> B x)
   (a0 : A) (a1 : A) (a : Id A a0 a1) :
   IdP (<x> B (a @ x)) (f a0) (f a1) =
   <x> f (a @ x)

fill0 (A0 : U) (A1 : U) (A : Id U A0 A1) (a0 : A0) : IdP A a0 (transport A a0) =
   <x> transport (<y> A @ (x/\y)) a0

hom_to_het_left (A0 : U) : (A1 : U) (A : Id U A0 A1)
                (a0 : A0) (a1 : A1)
                (p : Id A1 (transport A a0) a1) ->
                IdP A a0 a1 = 
  J U A0 (\ (A1 : U) (A : Id U A0 A1) -> 
         (a0 : A0) (a1 : A1)
         (p : Id A1 (transport A a0) a1) -> IdP A a0 a1)
       (\ (a0 : A0) (a1 : A0) (p : Id A0 (a0) a1) -> p)

hom_to_het_right (A0 : U) : (A1 : U) (A : Id U A0 A1)
                (a0 : A0) (a1 : A1)
                (p : Id A0 a0 (transport (<x> A @ -x) a1)) ->
                IdP A a0 a1 = 
  J U A0 (\ (A1 : U) (A : Id U A0 A1) -> 
         (a0 : A0) (a1 : A1)
         (p : Id A0 a0 (transport (<x> A @ -x) a1)) -> IdP A a0 a1)
       (\ (a0 : A0) (a1 : A0) (p : Id A0 (a0) a1) -> p)
  
transport_inv_r (A0 : U) (A1 : U) (A : Id U A0 A1) (a1 : A1) 
                 : Id A1 (transport A (transport (<x> A @ -x) a1)) a1 = 
    J U A0 (\ (A1 : U) (A : Id U A0 A1) -> (a1 : A1) -> Id A1 (transport A (transport (<x> A @ -x) a1)) a1)
           (\ (a1 : A0) -> <_> a1)
           A1 A a1

-- coe a : b -> c = (b/\c) \/ (b/\-a) \/ (c/\a)
-- coe z : x -> 0 = (x/\-z) 
-- coe z : 1 -> y = y \/ -z \/ (z/\y)

-- FIXME there should be a more direct proof
-- but normal form seems not that bad
funext_het_l (A0 A1 : U) (A : Id U A0 A1) :
             (B0 : A0 -> U) (B1 : A1 -> U) (B : IdP (<x> A @ x -> U) B0 B1) 
             (f0 : (a0 : A0) -> B0 a0) (f1 : (a1 : A1) -> B1 a1) 
             (f : (a0 : A0) -> IdP (<x> (B @ x) ((fill0 A0 A1 A a0) @ x)) (f0 a0) (f1 (transport A a0))) ->
             IdP (<x> (a : A @ x) -> (B @ x) a) f0 f1 = 
             J U A0 (\ (A1 : U) (A : Id U A0 A1) ->
                       (B0 : A0 -> U) (B1 : A1 -> U) (B : IdP (<x> A @ x -> U) B0 B1) 
                       (f0 : (a0 : A0) -> B0 a0) (f1 : (a1 : A1) -> B1 a1) 
                       (f : (a0 : A0) -> IdP (<x> (B @ x) ((fill0 A0 A1 A a0) @ x)) (f0 a0) (f1 (transport A a0))) 
                       -> IdP (<x> (a : A @ x) -> (B @ x) a) f0 f1)
                    (\ (B0 : A0 -> U) (B1 : A0 -> U) (B : IdP (<_> A0 -> U) B0 B1) 
                       (f0 : (a0 : A0) -> B0 a0) (f1 : (a1 : A0) -> B1 a1) 
                       (f : (a0 : A0) -> IdP (<x> (B @ x) a0) (f0 a0) (f1 a0)) 
                       -> <x> \ (a : A0) -> f a @ x) 
                    A1 A
             -- FIXME: doesn't have the right boundary?
             -- <x> \ (a : A @ x) -> transport (<w> (B @ x) ((transport_inv_r A0 (A@x) (<z> A @ (x /\ z)) a) @ w))
             --                                ((f (transport (<z> A @ (x /\ -z)) a)) @ x)

funext_het_l_constant_range (A0 A1 : U) (A : Id U A0 A1) : Unit -> 
                            (B : U)
                            (f0 : A0 -> B) (f1 : A1 -> B) 
                            (f : (a0 : A0) -> Id B (f0 a0) (f1 (transport A a0))) ->
                            IdP (<x> (a : A @ x) -> B) f0 f1 = split 
   tt ->
             J U A0 (\ (A1 : U) (A : Id U A0 A1) ->
                       (B : U)
                       (f0 : (a0 : A0) -> B) (f1 : (a1 : A1) -> B) 
                       (f : (a0 : A0) -> Id B (f0 a0) (f1 (transport A a0))) 
                       -> IdP (<x> (a : A @ x) -> B) f0 f1)
                    (\ (B : U) 
                       (f0 : (a0 : A0) -> B) (f1 : (a1 : A0) -> B) 
                       (f : (a0 : A0) -> Id B (f0 a0) (f1 a0)) 
                       -> <x> \ (a : A0) -> f a @ x) 
                    A1 A

-- funext_het (A0 A1 : U) (A : Id U A0 A1)
--            (B0 : A0 -> U) (B1 : A1 -> U) (B : IdP (<x> A @ x -> U) B0 B1) 
--            (f0 : (a0 : A0) -> B0 a0) (f1 : (a1 : A1) -> B1 a1) 
--            (f : (a0 : A0) (a1 : A1) (a : IdP A a0 a1) 
--                  -> IdP (<x> (B @ x) (a @ x)) (f0 a0) (f1 a1)) :
--            IdP (<x> (a : A @ x) -> (B @ x) a) f0 f1 = <x> \ (a : A @ x) -> f ? ? ? @ x

whisker_square_bot (A : U) (a0 a1 : A) (b0 b1 : A)
                 (top : Id A a0 a1)
                 (bot : Id A b0 b1)
                 (left : Id A a0 b0)
                 (right : Id A a1 b1) 
                 (sq : IdP (<x> Id A (top @ x) (bot @ x)) left right) 
                 (bot' : Id A b0 b1) (p : Id (Id A b0 b1) bot bot') : (IdP (<x> Id A (top @ x) (bot' @ x)) left right) = 
 <x> <y> comp A (sq @ x @ y) [(y = 1) -> <z> p @ z @ x ]

whisker_square_top (A : U) (t0 t1 : A) (b0 b1 : A)
                   (top : Id A t0 t1)
                   (bot : Id A b0 b1)
                   (left : Id A t0 b0)
                   (right : Id A t1 b1) 
                   (sq : IdP (<x> Id A (top @ x) (bot @ x)) left right) 
                   (top' : Id A t0 t1) (p : Id (Id A t0 t1) top top') : (IdP (<x> Id A (top' @ x) (bot @ x)) left right) = 
  <x> <y> comp A (sq @ x @ y) [(y = 0) -> <z> p @ z @ x]

-- normal form is pretty long
useIsEquivPropHeterogeneously (A B : U) (f g : A -> B) (p : Id (A -> B) f g) 
                              (e1 : isEquiv A B f) (e2 : isEquiv A B g)
                            : IdP (<x> isEquiv A B (p @ x)) e1 e2 = 
   J (A -> B) f (\ (g : A -> B) (p : Id (A -> B) f g) -> (e1 : isEquiv A B f) (e2 : isEquiv A B g) -> IdP (<x> isEquiv A B (p @ x)) e1 e2)
                (\ (e1 : isEquiv A B f) (e2 : isEquiv A B f) -> propIsEquiv A B f e1 e2)
                g p e1 e2

-- pretty short normal form
comp_inv_r (A : U) (a0 : A) : Unit -> (a1 : A) (p : Id A a0 a1)
          -> Id (Id A a0 a0) (<y> comp A (p @ y) [ (y = 1) -> <y> p @ -y ])
                             (<_> a0) = split
  tt -> 
   J A a0 (\ (a1 : A) (p : Id A a0 a1) ->
             Id (Id A a0 a0) (<y> comp A (p @ y) [ (y = 1) -> <y> p @ -y ]) (<_> a0))
          (<_> <_> a0)

comp_inv_r2 (A : U) (a0 : A) : Unit -> (a1 : A) (p : Id A a0 a1)
          -> Id (Id A a1 a1) (<y> comp A a0 [ (y = 0) -> p, (y = 1) -> <y> p @ y ])
                             (<_> a1) = split
  tt ->  
   J A a0 (\ (a1 : A) (p : Id A a0 a1) ->
             Id (Id A a1 a1) (<y> comp A a0 [ (y = 0) -> p, (y = 1) -> <y> p @ y ]) (<_> a1))
          (<_> <_> a0)

-- connection (A : U) (a b : A) (p : Id A a b) : IdP (<x> Id A (p @ x) b) p (<_> b) = 
--            <y><x> p @ (x \/ y)


-- ----------------------------------------------------------------------
-- circle

data S1 = base
        | loop <i> [(i=0) -> base, (i=1) -> base]

-- helpful abbreviations
OmegaS1 : U = Id S1 base base

compS1 (p : OmegaS1) (q : OmegaS1) : OmegaS1 = <x> comp S1 (p @ x) [(x=1) -> q]
loopS1 : OmegaS1 = <i> loop{S1} @ i
loopS1_2 : OmegaS1= compS1 loopS1 loopS1

-- "rotation by angle x"
-- adds loops

rotLoop : (a : S1) -> Id S1 a a = split
  base -> loopS1
  loop @ i -> constSquare S1 base loopS1 @ i

rot : S1 -> S1 -> S1 = split
  base -> (\ (y : S1) -> y)
  loop @ i -> (\ (y : S1) -> rotLoop y @ i)

loopS1_3 : Id S1 base base = compS1 loopS1_2 loopS1
test23 : IdP (<s> Id S1 (loopS1_3 @ s) (loopS1_3 @ s)) loopS1_2 loopS1_2 = <x> <y> rot (loopS1_3 @ x) (loopS1_2 @ y)
test23_diag : Id S1 base base = <x> test23 @ x @ x

rotIsEquiv_loop : Unit -> IdP (<x> isEquiv S1 S1 (rot (loopS1 @ x))) (idIsEquiv S1) (idIsEquiv S1) = split
  tt -> <x> useIsEquivPropHeterogeneously S1 S1 (\ (x : S1) -> x) (\ (x : S1) -> x) (<x> rot (loop{S1} @ x)) (idIsEquiv S1) (idIsEquiv S1) @ x 

rotIsEquiv : (a : S1) -> isEquiv S1 S1 (rot a) = split
   base -> idIsEquiv S1
   loop @ x -> rotIsEquiv_loop ABSTRACT @ x

rotId (x : S1) : Id U S1 S1 = isEquivEq S1 S1 (rot x) (rotIsEquiv x)

rot_comm (a : S1) (b : S1) : Id S1 (rot a b) (rot b a) = ?

-- ----------------------------------------------------------------------
-- suspensions 

data Susp (A : U) = north
                  | south
                  | merid (a:A) <i> [(i=0) -> north, (i=1) -> south]

S2 : U = Susp S1
S3 : U = Susp S2

merS3 (a : S2) : Id S3 north south = <y> merid{S3} a @ y
merS3ns : Id S3 north north = <x> comp S3 (merid{S3} north @ x) [(x=1) -> <y> merid{S3} south @ -y]


-- ----------------------------------------------------------------------
-- Hopf fibration

H : S2 -> U = split
  north -> S1
  south -> S1
  merid a @ x -> rotId a @ x

TH : U = (c : S2) * H c

-- ----------------------------------------------------------------------
-- Join

data Join (A : U) (B : U) = joinl (a : A)
                          | joinr (b : B)
                          | join (a:A) (b : B) <i> [(i=0) -> joinl a, (i=1) -> joinr b]


-- ----------------------------------------------------------------------
-- S1 join S1 and TH

joinS1S1 (a : S1) (b : S1) : Id (Join S1 S1) (joinl a) (joinr b) = <x> join{Join S1 S1} a b @ x

merS2 (a : S1) : Id S2 north south = <y> merid{S2} a @ y

in_north (a : S1) : (c : S2) * H c = (north , a)

in_south (a : S1) : (c : S2) * H c = (south , a)

gluens_1 (a : S1) (b : S1) : Id S2 north south = 
         <x> merS2 (transport (<z> rotId a @ -z) b) @ x

-- FIXME boundary checking doesn't work with referene to rot_comm because it's a hole
gluens_2 (a : S1) (b : S1) (rot_comm : (a : S1) (b : S1) -> Id S1 (rot a b) (rot b a))
         : Unit -> IdP (<x> H (gluens_1 a b @ x)) a b = split 
  tt -> 
    hom_to_het_left S1 S1 (<x> H (gluens_1 a b @ x)) a b 
        (<x> comp S1 ((transport_inv_r S1 S1 (rotId a) b) @ x) [(x=0) -> (rot_comm a (transport (<x> rotId a @ -x) b))])

gluens (a : S1) (b : S1) : Unit -> Id TH (in_north a) (in_south b) = split 
  tt -> 
    <x> (gluens_1 a b @ x , 
         gluens_2 a b rot_comm ABSTRACT @ x)

Join_to_TH : Join S1 S1 -> TH = split
  joinl a -> in_north a
  joinr b -> in_south b
  join a b @ x -> gluens a b NONABSTRACT @ x

TH_to_Join' : (x : S2) -> H x -> Join S1 S1 = split
   north -> \ (a : S1) -> joinl a
   south -> \ (a : S1) -> joinr a
   merid a @ x -> 
    (funext_het_l_constant_range S1 S1 (<x> (H (merid{S2} a @ x))) ABSTRACT (Join S1 S1) 
                     (\ (a : S1) -> joinl a) (\ (a : S1) -> joinr a)
                     (\ (b : S1) -> joinS1S1 b (rot a b)))@x

TH_to_Join (p : TH) : Join S1 S1 = TH_to_Join' p.1 p.2

-- JTH1 : (a : Join S1 S1) -> Id (Join S1 S1) (TH_to_Join (Join_to_TH a)) a = split
--   joinl a -> <_> joinl a
--   joinr b -> <_> joinr b
--   join a b @ x -> ?

-- IdP (<!0> Join (S1, S1))
--   (funext_het_l_constant_range 
--     (S1, S1, <!0> glue (S1) [ (!0 = 0) -> (S1,(rot (((rotIsEquiv a b).2).1),(\(y : S1) -> ((rotIsEquiv (((rotIsEquiv a b).2).1) y).2).1,(\(y : S1) -> <!0> ((rotIsEquiv (((rotIsEquiv a b).2).1) y).2).2 @ -!0,\(x : S1) -> <!0> ((rotIsEquiv (((rotIsEquiv a b).2).1) (rot (((rotIsEquiv a b).2).1) x)).1 ((((rotIsEquiv (((rotIsEquiv a b).2).1) (rot (((rotIsEquiv a b).2).1) x)).2).1,((rotIsEquiv (((rotIsEquiv a b).2).1) (rot (((rotIsEquiv a b).2).1) x)).2).2)) ((x,<!0> rot (((rotIsEquiv a b).2).1) x)) @ !0).1)))) ])
--     (?)
--     (Join (S1, S1))
--     (\(a0 : S1) -> joinl a0)
--     (\(a0 : S1) -> joinr a0) 
--     (\(b0 : S1) -> <!0> join {Join (S1, S1)} b0 (rot (((rotIsEquiv a b).2).1) b0) @ !0) @ x 
--     (gluens_2 (a, b, \(a0 b0 : S1) -> ? (a = a0, b = b0)) (?) @ x)) 
--     (join {Join (S1, S1)} a b @ x)

-- JTH2' : (a : S2) -> (h : H a) -> Id TH (Join_to_TH (TH_to_Join' a h)) (a,h) = split
--   north -> \ (a : S1) -> <_> (north, a)
--   south -> \ (b : S1) -> <_> (south, b)
--   merid a @ x -> mcase a @ x where
--     mcase (a : S1) : IdP (<x> (h : H (merS2 a @ x)) -> Id TH (Join_to_TH (TH_to_Join' (merS2 a @ x) h)) ((merS2 a @ x),h)) 
--                          (\ (a : S1) -> <_> (north, a))
--                          (\ (b : S1) -> <_> (south, b)) = 
--         funext_het_l S1 S1 (<x> (H (merS2 a @ x)))
--                      (\ (h : S1) -> Id TH (Join_to_TH (TH_to_Join' north h)) (north,h))
--                      (\ (h : S1) -> Id TH (Join_to_TH (TH_to_Join' south h)) (south,h))
--                      (<x> \ (h : H (merS2 a @ x)) -> Id TH (Join_to_TH (TH_to_Join' (merS2 a @ x) h)) ((merS2 a @ x),h)) 
--                      (\ (a : S1) -> <_> (north, a))
--                      (\ (b : S1) -> <_> (south, b))
--                      ?

-- (a00 : S1) -> IdP (<!0> IdP (<!1> Sigma (Susp (S1)) (\ (c : Susp (S1)) -> H c))
--  (Join_to_TH (funext_het_l_constant_range (S1, S1, <!1> glue (S1) [ (!1 = 0) -> (S1,(rot a0,(\ (y : S1) -> ((rotIsEquiv a0 y).2).1,(\ (y : S1) -> <!0> ((rotIsEquiv a0 y).2).2 @ -!0,\ (x : S1) -> <!0> ((rotIsEquiv a0 (rot a0 x)).1 ((((rotIsEquiv a0 (rot a0 x)).2).1,((rotIsEquiv a0 (rot a0 x)).2).2)) ((x,<!0> rot a0 x)) @ !0).1)))) ])
--                                           (?)
--                                           (Join (S1, S1))
--                                           (\ (a1 : S1) -> joinl a1)
--                                           (\ (a1 : S1) -> joinr a1) 
--                                           (\ (b : S1) -> <!0> join {Join (S1, S1)} b (rot a0 b) @ !0) @ !0 
--                                                               (glueElem (rot a0 a00) [ (!0 = 0) -> a00 ])))
--                                            ((merid {Susp (S1)} a0 @ !0,glueElem (rot a0 a00) [ (!0 = 0) -> a00 ]))) 
--  (<!0> (north,a00)) 
--  (<!0> (south,rot a0 a00))

-- ----------------------------------------------------------------------
-- assoc of join

rearrange (A : U) (t0 : A) (b0 b1 : A)
          (bot : Id A b0 b1)
          (left : Id A t0 b0)
          (right : Id A t0 b1) 
          (sq : IdP (<x> Id A t0 (bot @ x)) left right) :
          (IdP (<x> Id A (left @ x) b1) right bot) = ?

rearrange' (A : U) (t0 : A) (b0 b1 : A)
           (newbot : Id A b0 b1)
           (newleft : Id A t0 b0)
           (newright : Id A t0 b1) 
           (sq : IdP (<x> Id A (newleft @ x) b1) newright newbot) : (IdP (<x> Id A t0 (newbot @ x)) newleft newright) = ?

jassoc_lr_l (A B C : U) : Join A B -> Join A (Join B C) = split 
   joinl a -> joinl a
   joinr b -> joinr (joinl b)
   join a b @ x -> join{Join A (Join B C)} a (joinl b) @ x

jassoc_lr_j (A B C : U) (c : C)
            (rearrange : (A : U) (t0 : A) (b0 b1 : A)
                  (bot : Id A b0 b1)
                  (left : Id A t0 b0)
                  (right : Id A t0 b1) 
                  (sq : IdP (<x> Id A t0 (bot @ x)) left right) ->
                  (IdP (<x> Id A (left @ x) b1) right bot))
           : (ab : Join A B) -> Id (Join A (Join B C)) (jassoc_lr_l A B C ab) (joinr (joinr c)) = split 
   joinl a -> <y> join{Join A (Join B C)} a (joinr c) @ y
   joinr b -> <y> joinr (join{Join B C} b c @ y)
   join a b @ x -> <y> rearrange (Join A (Join B C)) (joinl a) (joinr (joinl b)) (joinr (joinr c)) 
                                 (<x> joinr (join{Join B C} b c @ x))
                                 (<x> join{Join A (Join B C)} a (joinl b) @ x)
                                 (<x> join{Join A (Join B C)} a (joinr c) @ x)
                                 (<x> <y> join{Join A (Join B C)} a (join{Join B C} b c @ x) @ y)
                        @ x @ y

jassoc_lr (A B C : U) : Join (Join A B) C -> Join A (Join B C) = split
    joinl ab -> jassoc_lr_l A B C ab
    joinr c -> joinr (joinr c)
    join ab c @ x -> jassoc_lr_j A B C c rearrange ab @ x

jassoc_rl_r (A B C : U) : Join B C -> Join (Join A B) C = split 
   joinl b -> joinl (joinr b)
   joinr c -> joinr c
   join b c @ x -> join{Join (Join A B) C} (joinr b) c @ x

jassoc_rl_j (A B C : U) (a : A)
         (rearrange' : (A : U) (t0 : A) (b0 b1 : A)
           (newbot : Id A b0 b1)
           (newleft : Id A t0 b0)
           (newright : Id A t0 b1) 
           (sq : IdP (<x> Id A (newleft @ x) b1) newright newbot) ->
           (IdP (<x> Id A t0 (newbot @ x)) newleft newright))
 : (bc : Join B C) -> Id (Join (Join A B) C) (joinl (joinl a)) (jassoc_rl_r A B C bc) = split 
   joinl b -> <x> joinl (join{Join A B} a b @ x)
   joinr c -> <x> join{Join (Join A B) C} (joinl a) c @ x
   join b c @ x -> <y>(rearrange' (Join (Join A B) C) (joinl (joinl a)) (joinl (joinr b)) (joinr c)
                                  (<x> join{Join (Join A B) C} (joinr b) c @ x)
                                  (<x> joinl (join{Join A B} a b @ x))
                                  (<x> join{Join (Join A B) C} (joinl a) c @ x)
                                  (<x><y> join{Join (Join A B) C} (join{Join A B} a b @ x) c @ y)
                         )@x@y

jassoc_rl (A B C : U) : Join A (Join B C) -> Join (Join A B) C = split
     joinl a -> joinl (joinl a)
     joinr bc -> jassoc_rl_r A B C bc
     join a bc @ x -> jassoc_rl_j A B C a rearrange' bc @ x

-- ----------------------------------------------------------------------
-- suspension and join with booleans

-- join Bool A is a "fat" suspension, with an inm construct including A, and paths from N to inm(x) to S
-- inl true = N
-- inl false = S
-- inr x = inm x

data Bool = true | false

fatten (A : U) : Susp A -> Join Bool A = split
   north -> joinl true
   south -> joinl false
   merid a @ x -> comp (Join Bool A) (join{Join Bool A} true a @ x) [(x = 1) -> <x> (join{Join Bool A} false a @ -x)]

thinb (A : U) : Bool -> Susp A = split
  true -> north
  false -> south

thin_j (A : U) (a : A) : (b : Bool) -> Id (Susp A) (thinb A b) south = split
  true -> <x> merid{Susp A} a @ x
  false -> <_> south

thin (A : U) : Join Bool A -> Susp A = split
   joinl b -> thinb A b
   joinr _ -> south
   join b a @ x -> thin_j A a b @ x

fat_thin (A : U) : (t : Susp A) -> Id (Susp A) (thin A (fatten A t)) t = split
  north -> <_> north
  south -> <_> south
  merid a @ x -> <_> merid{Susp A} a @ x

thin_fat (A : U) : (f : Join Bool A) -> Id (Join Bool A) (fatten A (thin A f)) f = split
  inl b -> ?
  inr b -> ?
  join b a @ x -> ?

{-

-- ----------------------------------------------------------------------
-- pointed types

PointedType : U = (A : U) * A

Omega (A : PointedType) : PointedType = (Id A.1 A.2 A.2 , <_> A.2)

PointedMap (A : PointedType) (B : PointedType) : U = 
   (f : A.1 -> B.1) * (Id (B.1) (f A.2) B.2)

OmegaF (A B : PointedType) (f : PointedMap A B) : PointedMap (Omega A) (Omega B) = 
       ((\ (p : (Omega A).1) -> <x> (comp B.1 (f.1 (p @ x)) [(x=1) -> f.2, (x=0) -> f.2])) ,
        comp_inv_r2 B.1 (f.1 A.2) ABSTRACT B.2 f.2)

SuspP (A : PointedType) : PointedType = (Susp A.1, north)

meridP (A : PointedType) : PointedMap A (Omega(SuspP A)) = 
  ((\ (a : A.1) -> <x> comp (Susp A.1) (merid{Susp A.1} a @ x) [(x = 1) -> <x> merid{Susp A.1} A.2 @ -x]),
   comp_inv_r (Susp A.1) north ABSTRACT south (<x> merid{Susp A.1} A.2 @ x))

S1P : PointedType = (S1, base)

S2P : PointedType = SuspP S1P

OmegaS1_to_Omega2S2 : PointedMap (Omega S1P) (Omega (Omega S2P)) = OmegaF S1P (Omega S2P) (meridP S1P)

loopS2 : (Omega(Omega(S2P))).1 = OmegaS1_to_Omega2S2.1 loopS1
-- seems a little more complicated than what I wrote by hand?
-- loopS2_1' : Id (Id S2 north north) 
--                (<y> comp S2 (merid{S2} base @ y) [ (y = 1) -> <y> merid{S2} base @ -y ])
--                (<y> comp S2 (merid{S2} base @ y) [ (y = 1) -> <y> merid{S2} base @ -y ]) =
--          <x> <y> comp S2 (merid{S2} (loop{S1} @x) @ y) [ (y = 1) -> <y> merid{S2} base @ -y ]
-- loopS2 : Id (Id S2 north north) (<_> north) (<_> north) = 
--     <z> comp (Id S2 north north) 
--              (loopS2_1' @ z)
--              [(z = 0) -> comp_inv_r S2 north south (<y> merid{S2} base @ y),
--               (z = 1) -> comp_inv_r S2 north south (<y> merid{S2} base @ y)]

S3P : PointedType = SuspP S2P

Omega2S2_to_Omega3S3 : PointedMap (Omega (Omega S2P)) (Omega (Omega (Omega S3P))) = 
                     OmegaF (Omega S2P) (Omega (Omega S3P)) (OmegaF S2P (Omega S3P) (meridP S2P))

loopS3 : Id (Id (Id S3 north north) (<_> north) (<_> north)) (<_> <_> north) (<_> <_> north) = 
         Omega2S2_to_Omega3S3.1 loopS2

THP : PointedType = (TH , (north, base))

S3_to_TH_P_constant : PointedMap S3P THP = (\ (x : S3) -> (north,base), <_> (north, base)) 
S3_to_TH_P : PointedMap S3P THP = (S3_to_TH, <_> (north, base))

Omega3S3_to_Omega3TH : PointedMap (Omega (Omega (Omega S3P))) (Omega (Omega (Omega THP))) =
         OmegaF (Omega (Omega S3P)) (Omega (Omega THP))
                (OmegaF (Omega S3P) (Omega THP) (OmegaF S3P THP S3_to_TH_P))

test : (Omega (Omega (Omega THP))).1 = Omega3S3_to_Omega3TH.1 loopS3

     
-}